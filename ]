import pygame, random, math, numpy, os, sys

class Player:
    def __init__(self, pos, size, speed, color, bullet_size, bullet_speed, health, damage, game):
        self.rect = pygame.Rect(pos, size)
        self.color = color
        self.health = health
        self.damage = damage
        self.speed = speed
        self.game = game
        self.bullet_size = bullet_size
        self.bullet_speed = bullet_speed

        self.left = False
        self.right = False
        self.up = False
        self.down = False

        self.next_damage = 0
        self.damage_cooldown = 1500
        
        self.next_shot = 0
        self.shot_cooldown = 500

        self.shoot_left = False
        self.shoot_right = False
        self.shoot_up = False
        self.shoot_down = False

        self.dead = False


    def update(self):
        if self.left and self.rect.x > 0: 
            self.rect.x -= self.speed
        if self.right and self.rect.x + self.rect.w  < self.game.WINDOW_SIZE[0]:
            self.rect.x += self.speed
        if self.up and self.rect.y > 0:
            self.rect.y -= self.speed
        if self.down and self.rect.y + self.rect.h < self.game.WINDOW_SIZE[1]:
            self.rect.y += self.speed
        
        if (self.shoot_left or self.shoot_right or self.shoot_down or self.shoot_up) and pygame.time.get_ticks() > self.next_shot:
            self.next_shot = pygame.time.get_ticks() + self.shot_cooldown
            center = (self.rect.x + (self.rect.w/2), self.rect.y + (self.rect.h/2))
             
            if self.shoot_left:
                self.game.player_bullets.append([pygame.Vector2(center[0], center[1]), (-1 * self.bullet_speed, 0)])

            elif self.shoot_right:
                self.game.player_bullets.append([pygame.Vector2(center[0], center[1]), (1 * self.bullet_speed, 0)])

            elif self.shoot_down:
                self.game.player_bullets.append([pygame.Vector2(center[0], center[1]), (0, 1 * self.bullet_speed)])

            elif self.shoot_up:
                self.game.player_bullets.append([pygame.Vector2(center[0], center[1]), (0, -1 * self.bullet_speed)])


    def draw(self, display):
        pygame.draw.rect(display, self.color, self.rect)

    def take_damage(self, dmg):
        if pygame.time.get_ticks() > self.next_damage:
            self.health -= dmg
            self.next_damage = pygame.time.get_ticks() + self.damage_cooldown

            if self.health <= 0:
                for i in range(50):
                    self.game.particles.append([pygame.Vector2(self.rect.x + (self.rect.w/2), self.rect.y + (self.rect.h/2)), (self.color[0] - 15, self.color[1] - 0, self.color[2] - 0)])
                self.dead = True

            elif self.health >= 0:
                for i in range(10):
                    self.game.particles.append([pygame.Vector2(self.rect.x + (self.rect.w/2), self.rect.y + (self.rect.h/2)), (self.color[0] - 15, self.color[1] - 15, self.color[2] - 15)])


class Enemy:
    def __init__(self, pos, size, speed, color, bullet_size, bullet_speed, shot_cooldown, health, damage, game, follow=False, wander=True, shooter=False):
        self.rect = pygame.Rect(pos, size)
        self.velocity = pygame.Vector2(0, 0)
        self.speed = speed
        self.game = game
        self.color = color
        self.velocity = pygame.Vector2(0, 0)

        self.shooter = shooter
        self.next_shot = random.uniform(0, 10000)
        self.shot_cooldown = shot_cooldown
        self.bullet_size = bullet_size
        self.bullet_speed = bullet_speed

        self.health = health
        self.damage = damage

        self.follow = follow

        self.wander = wander
        self.next_wander = random.uniform(0, 1000)
        self.wander_interval = random.uniform(1500, 2000)
        
        self.left = False
        self.right = False
        self.down = False
        self.up = False

        self.dead = False

    
    def update(self):
        if self.rect.colliderect(self.game.player.rect):
            self.game.player.take_damage(self.damage)
        
        if not self.follow and self.wander:
            if pygame.time.get_ticks() > self.next_wander:
                self.left = False
                self.right = False
                self.down = False
                self.up = False

                self.next_wander = pygame.time.get_ticks() + self.wander_interval
                direction = random.randint(1, 4)

                if direction == 1:
                    self.left = True
                elif direction == 2:
                    self.right = True
                elif direction == 3:
                    self.up = True
                elif direction == 4:
                    self.down = True

            if self.rect.x <= 0 or self.rect.x + self.rect.w >= self.game.WINDOW_SIZE[0] or self.rect.y <= 0 or self.rect.y + self.rect.h >= self.game.WINDOW_SIZE[1]: 
                self.next_wander = pygame.time.get_ticks()

            if self.left and self.rect.x > 0: 
                self.velocity.x = -self.speed
            if self.right and self.rect.x + self.rect.w  < self.game.WINDOW_SIZE[0]:
                self.velocity.x = self.speed
            if self.up and self.rect.y > 0:
                self.velocity.y = -self.speed
            if self.down and self.rect.y + self.rect.h < self.game.WINDOW_SIZE[1]:
                self.velocity.y = self.speed

        elif self.follow:
            x, y = self.get_player_pos()
            self.velocity.x = x * self.speed
            self.velocity.y = y * self.speed

        if self.shooter and pygame.time.get_ticks() > self.next_shot:
            self.next_shot = pygame.time.get_ticks() + self.shot_cooldown
            self.shoot()

        self.rect.x += self.velocity.x
        enemy_rects = []
        for enemy in self.game.enemies:
            if enemy != self:
                enemy_rects.append(enemy.rect)
        collisions = self.rect.collidelistall(enemy_rects)
        for enemy_rect in collisions:
            if self.velocity.x > 0:
                self.rect.right = enemy_rects[enemy_rect].left
            elif self.velocity.x < 0:
                self.rect.left = enemy_rects[enemy_rect].right

        self.rect.y += self.velocity.y
        enemy_rects = []
        for enemy in self.game.enemies:
            if enemy != self:
                enemy_rects.append(enemy.rect)
        collisions = self.rect.collidelistall(enemy_rects)
        for enemy_rect in collisions:
            if self.velocity.y > 0:
                self.rect.bottom = enemy_rects[enemy_rect].top
            elif self.velocity.y < 0:
                self.rect.top = enemy_rects[enemy_rect].bottom

    def shoot(self):
        print("Shoot")


    def get_player_pos(self):
        player_pos = pygame.Vector2(self.game.player.rect.x + (self.game.player.rect.w/2), self.game.player.rect.y + (self.game.player.rect.h/2))
        pos = pygame.Vector2(self.rect.x + (self.rect.w/2), self.rect.y + (self.rect.h/2))

        x = player_pos.x - pos.x 
        y = player_pos.y - pos.y
        length = math.sqrt((x**2) + (y**2))
        if length != 0:
            x /= length
            y /= length
        else:
            x = 0
            y = 0

        return x, y

    
    def draw(self, display):
        pygame.draw.rect(display, self.color, self.rect)

    def die(self):
        for i in range(50):
            self.game.particles.append([pygame.Vector2(self.rect.x + (self.rect.w/2), self.rect.y + (self.rect.h/2)), (self.color[0] - 15, self.color[1] - 0, self.color[2] - 0)])
        self.game.enemies.remove(self)


    def take_damage(self, dmg):
        self.health -= dmg

        if self.health <= 0:
            self.die()

        elif self.health >= 0:
            for i in range(10):
                self.game.particles.append([pygame.Vector2(self.rect.x + (self.rect.w/2), self.rect.y + (self.rect.h/2)), (self.color[0] - (self.color[0] * 1/4), self.color[1] - 0, self.color[2] - 0)])



class Giant(Enemy):
    def shoot(self):
        bullet_speed = self.bullet_speed
        xd, yd = (abs(self.game.player.rect.x - self.rect.x), abs(self.game.player.rect.y - self.rect.y))
        center = (self.rect.x + (self.rect.w/2), self.rect.y + (self.rect.h/2))

        if xd > yd:
            if self.game.player.rect.x > self.rect.x:
                self.game.enemy_bullets.append([pygame.Vector2(center[0], center[1]), (1 * self.bullet_speed, bullet_speed), self.damage, self.bullet_size])
                self.game.enemy_bullets.append([pygame.Vector2(center[0], center[1]), (1 * self.bullet_speed, 0), self.damage, self.bullet_size])
                self.game.enemy_bullets.append([pygame.Vector2(center[0], center[1]), (1 * self.bullet_speed, -bullet_speed), self.damage, self.bullet_size])
            else:
                self.game.enemy_bullets.append([pygame.Vector2(center[0], center[1]), (-1 * self.bullet_speed, bullet_speed), self.damage, self.bullet_size])
                self.game.enemy_bullets.append([pygame.Vector2(center[0], center[1]), (-1 * self.bullet_speed, 0), self.damage, self.bullet_size])
                self.game.enemy_bullets.append([pygame.Vector2(center[0], center[1]), (-1 * self.bullet_speed, -bullet_speed), self.damage, self.bullet_size])
        elif xd < yd:
            if self.game.player.rect.y > self.rect.y:
                self.game.enemy_bullets.append([pygame.Vector2(center[0], center[1]), (bullet_speed, 1 * self.bullet_speed), self.damage, self.bullet_size])
                self.game.enemy_bullets.append([pygame.Vector2(center[0], center[1]), (0, 1 * self.bullet_speed), self.damage, self.bullet_size])
                self.game.enemy_bullets.append([pygame.Vector2(center[0], center[1]), (-bullet_speed, 1 * self.bullet_speed), self.damage, self.bullet_size])
            else:
                self.game.enemy_bullets.append([pygame.Vector2(center[0], center[1]), (bullet_speed, -1 * self.bullet_speed), self.damage, self.bullet_size])
                self.game.enemy_bullets.append([pygame.Vector2(center[0], center[1]), (0, -1 * self.bullet_speed), self.damage, self.bullet_size])
                self.game.enemy_bullets.append([pygame.Vector2(center[0], center[1]), (-bullet_speed, -1 * self.bullet_speed), self.damage, self.bullet_size])
        else:
            self.next_shot = pygame.time.get_ticks()



class Baby(Enemy):
    def shoot(self):
        center = (self.rect.x + (self.rect.w/2), self.rect.y + (self.rect.h/2))

        if self.velocity.x > 0:
            self.game.enemy_bullets.append([pygame.Vector2(center[0], center[1]), (self.bullet_speed, 0), self.damage, self.bullet_size])
        elif self.velocity.x < 0:
            self.game.enemy_bullets.append([pygame.Vector2(center[0], center[1]), (-self.bullet_speed, 0), self.damage, self.bullet_size])

class Goblin(Enemy):
    def shoot(self):
        center = (self.rect.x + (self.rect.w/2), self.rect.y + (self.rect.h/2))

        self.game.enemy_bullets.append([pygame.Vector2(center[0], center[1]), (self.bullet_speed, 0), self.damage, self.bullet_size])
        self.game.enemy_bullets.append([pygame.Vector2(center[0], center[1]), (-self.bullet_speed, 0), self.damage, self.bullet_size])


class Boomer(Enemy):
    def die(self):
        super().die()

        self.game.enemies.append(Baby(pygame.Vector2(self.rect.x, self.rect.y), (20, 30), 3.5, (random.randint(120, 255), 0, 0), 10, 5, 5000, 10, 10, self.game, False, True, True))
        self.game.enemies.append(Baby(pygame.Vector2(self.rect.x, self.rect.y), (20, 30), 3.5, (random.randint(120, 255), 0, 0), 10, 5, 5000, 10, 10, self.game, False, True, True))

class Game:
    def __init__(self, WINDOW_SIZE, title):
        os.environ['SDL_VIDEO_CENTERED'] = '1'
        pygame.init()
        self.clock = pygame.time.Clock()

        self.WINDOW_SIZE = WINDOW_SIZE
        self.display = pygame.display.set_mode(self.WINDOW_SIZE)
        pygame.display.set_caption(title)

        self.player_bullets = []
        self.enemy_bullets = []
        self.player = Player(pygame.Vector2(400, 400), (40, 40), 5, (100, 150, 255), 8, 10, 100, 10, self)
        self.enemies = []
        for i in range(5):
            color = random.randint(120, 255)
            self.enemies.append(Boomer(pygame.Vector2(random.randint(0, 800), random.randint(0, 800)), (60, 60), 2, (color, 0, 0), 15, 4, 2000, 10, 10, self, False, True, False))
            self.enemies.append(Giant(pygame.Vector2(random.randint(0, 800), random.randint(0, 800)), (60, 60), 2, (color, color, 0), 25, 3, 5000, 10, 10, self, True, False, True))
            self.enemies.append(Goblin(pygame.Vector2(random.randint(0, 800), random.randint(0, 800)), (30, 40), 3, (0, color, 0), 15, 4, 2000, 10, 10, self, True, False, True))


        self.particles = []


    def render(self):
        self.display.fill((0, 0, 0))

        for enemy in self.enemies:
            enemy.draw(self.display)
        self.player.draw(self.display)

        for bullet in self.player_bullets:
            pygame.draw.circle(self.display, (255, 255, 255), bullet[0], self.player.bullet_size)

        for bullet in self.enemy_bullets:
            pygame.draw.circle(self.display, (255, 255, 255), bullet[0], bullet[3])

        for particle in self.particles:
            pygame.draw.circle(self.display, particle[1], particle[0], 5, 3)

        pygame.display.update()


    def event_handler(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    pygame.quit()
                    sys.exit()

                elif event.key == pygame.K_w:
                    self.player.up = True

                elif event.key == pygame.K_s:
                    self.player.down = True

                elif event.key == pygame.K_a:
                    self.player.left = True

                elif event.key == pygame.K_d:
                    self.player.right = True

                elif event.key == pygame.K_j:
                    self.player.shoot_left = True
                
                elif event.key == pygame.K_l:
                    self.player.shoot_right = True

                elif event.key == pygame.K_i:
                    self.player.shoot_up = True

                elif event.key == pygame.K_k:
                    self.player.shoot_down = True

            elif event.type == pygame.KEYUP:
                if event.key == pygame.K_w:
                    self.player.up = False

                elif event.key == pygame.K_s:
                    self.player.down = False

                elif event.key == pygame.K_a:
                    self.player.left = False

                elif event.key == pygame.K_d:
                    self.player.right = False

                elif event.key == pygame.K_j:
                    self.player.shoot_left = False
                
                elif event.key == pygame.K_l:
                    self.player.shoot_right = False

                elif event.key == pygame.K_i:
                    self.player.shoot_up = False

                elif event.key == pygame.K_k:
                    self.player.shoot_down = False

    def update(self):
        self.player.update()

        for bullet in self.player_bullets:
            if bullet[0].x > self.WINDOW_SIZE[0] or bullet[0].x < 0 or bullet[0].y < 0 or bullet[0].y > self.WINDOW_SIZE[1]:
                self.player_bullets.remove(bullet)
                continue
            
            collided_enemy = pygame.Rect(bullet[0].x - self.player.bullet_size, bullet[0].y - self.player.bullet_size, self.player.bullet_size * 2, self.player.bullet_size * 2).collidelist(self.enemies)
            if collided_enemy != -1:
                self.enemies[collided_enemy].take_damage(self.player.damage)
                self.player_bullets.remove(bullet)
                continue

            bullet[0].x += bullet[1][0]
            bullet[0].y += bullet[1][1]
        
        for bullet in self.enemy_bullets:
            if bullet[0].x > self.WINDOW_SIZE[0] or bullet[0].x < 0 or bullet[0].y < 0 or bullet[0].y > self.WINDOW_SIZE[1]:
                self.enemy_bullets.remove(bullet)
            
            bullet[0].x += bullet[1][0]
            bullet[0].y += bullet[1][1]


        for particle in self.particles:
            if particle[0].x > self.WINDOW_SIZE[0] or particle[0].x < 0 or particle[0].y < 0 or particle[0].y > self.WINDOW_SIZE[1]:
                self.particles.remove(particle)

            if len(particle) <= 2:
                particle.append(pygame.Vector2(random.uniform(-3, 3), random.uniform(-3, -1)))

            particle[2].y += .2
            particle[0].x += particle[2].x
            particle[0].y += particle[2].y

        for enemy in self.enemies:
            enemy.update()


    def run(self):
        self.event_handler()
        self.update()
        self.render()
        self.clock.tick(60)


if __name__ == '__main__':
    game = Game((800, 800), "Top Down Game")
    while True:
        game.run()
